{
  "version": 3,
  "sources": ["../src/env.ts", "../src/api/openai_api.ts", "../src/api/telegram.ts", "../src/index.ts"],
  "sourceRoot": "dist",
  "sourcesContent": ["export interface Env {\r\n  OPENAI_API_KEY: string;\r\n  OPENAI_BASE_URL: string;\r\n  OPENAI_MODELS: string; // Comma-separated list of available OpenAI models\r\n  TELEGRAM_BOT_TOKEN: string;\r\n  WHITELISTED_USERS: string; // Comma-separated list of allowed Telegram user IDs\r\n  SYSTEM_INIT_MESSAGE: string;\r\n  SYSTEM_INIT_MESSAGE_ROLE: string;\r\n  DEFAULT_MODEL?: string; // Optional default model\r\n}\r\n\r\nconst getEnvOrDefault = (env: Env, key: keyof Env, defaultValue: string): string => {\r\n  return (env[key] as string) || defaultValue;\r\n};\r\n\r\nexport const getConfig = (env: Env) => ({\r\n  openaiApiKey: env.OPENAI_API_KEY,\r\n  openaiBaseUrl: getEnvOrDefault(env, 'OPENAI_BASE_URL', 'https://api.openai.com/v1'),\r\n  openaiModels: env.OPENAI_MODELS.split(',').map(model => model.trim()),\r\n  telegramBotToken: env.TELEGRAM_BOT_TOKEN,\r\n  whitelistedUsers: env.WHITELISTED_USERS.split(',').map(id => id.trim()),\r\n  systemInitMessage: getEnvOrDefault(env, 'SYSTEM_INIT_MESSAGE', 'You are a helpful assistant.'),\r\n  systemInitMessageRole: getEnvOrDefault(env, 'SYSTEM_INIT_MESSAGE_ROLE', 'system'),\r\n  defaultModel: env.DEFAULT_MODEL\r\n});", "import { Env, getConfig } from '../env';\r\n\r\ninterface Message {\r\n  role: 'system' | 'user' | 'assistant';\r\n  content: string;\r\n}\r\n\r\ninterface ChatCompletionResponse {\r\n  id: string;\r\n  object: string;\r\n  created: number;\r\n  model: string;\r\n  choices: {\r\n    index: number;\r\n    message: Message;\r\n    finish_reason: string;\r\n  }[];\r\n  usage: {\r\n    prompt_tokens: number;\r\n    completion_tokens: number;\r\n    total_tokens: number;\r\n  };\r\n}\r\n\r\nexport class OpenAIAPI {\r\n  private apiKey: string;\r\n  private baseUrl: string;\r\n  private models: string[];\r\n  private defaultModel: string;\r\n\r\n  constructor(env: Env) {\r\n    const config = getConfig(env);\r\n    this.apiKey = config.openaiApiKey;\r\n    this.baseUrl = config.openaiBaseUrl;\r\n    this.models = config.openaiModels;\r\n    this.defaultModel = config.defaultModel || this.models[0];\r\n  }\r\n\r\n  async generateResponse(messages: Message[], model?: string): Promise<string> {\r\n    const url = `${this.baseUrl}/chat/completions`;\r\n    const response = await fetch(url, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'Authorization': `Bearer ${this.apiKey}`,\r\n      },\r\n      body: JSON.stringify({\r\n        model: model || this.defaultModel,\r\n        messages: messages,\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`OpenAI API error: ${response.statusText}`);\r\n    }\r\n\r\n    const data: ChatCompletionResponse = await response.json();\r\n    return data.choices[0].message.content.trim();\r\n  }\r\n\r\n  isValidModel(model: string): boolean {\r\n    return this.models.includes(model);\r\n  }\r\n\r\n  getDefaultModel(): string {\r\n    return this.defaultModel;\r\n  }\r\n\r\n  getAvailableModels(): string[] {\r\n    return this.models;\r\n  }\r\n}\r\n\r\nexport default OpenAIAPI;", "import { Env, getConfig } from '../env';\r\nimport { TelegramTypes } from '../../types/telegram';\r\nimport OpenAIAPI from './openai_api';\r\n\r\nexport class TelegramBot {\r\n  private token: string;\r\n  private apiUrl: string;\r\n  private whitelistedUsers: number[];\r\n  private openai: OpenAIAPI;\r\n  private systemMessage: string;\r\n\r\n  constructor(env: Env) {\r\n    const config = getConfig(env);\r\n    this.token = config.telegramBotToken;\r\n    this.apiUrl = `https://api.telegram.org/bot${this.token}`;\r\n    this.whitelistedUsers = config.whitelistedUsers.map(Number);\r\n    this.openai = new OpenAIAPI(env);\r\n    this.systemMessage = config.systemInitMessage;\r\n  }\r\n\r\n  async sendMessage(chatId: number, text: string): Promise<TelegramTypes.SendMessageResult> {\r\n    const url = `${this.apiUrl}/sendMessage`;\r\n    const response = await fetch(url, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        chat_id: chatId,\r\n        text: text,\r\n        parse_mode: 'Markdown',\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`HTTP error! status: ${response.status}`);\r\n    }\r\n\r\n    return await response.json();\r\n  }\r\n\r\n  async handleUpdate(update: TelegramTypes.Update): Promise<void> {\r\n    if (update.message && update.message.text) {\r\n      const chatId = update.message.chat.id;\r\n      const userId = update.message.from?.id;\r\n      const text = update.message.text;\r\n\r\n      if (userId && this.isUserWhitelisted(userId)) {\r\n        try {\r\n          const response = await this.openai.generateResponse([\r\n            { role: 'system', content: this.systemMessage },\r\n            { role: 'user', content: text }\r\n          ]);\r\n          await this.sendMessage(chatId, response);\r\n        } catch (error) {\r\n          console.error('Error generating response:', error);\r\n          await this.sendMessage(chatId, \"Sorry, I couldn't generate a response. Please try again later.\");\r\n        }\r\n      } else {\r\n        await this.sendMessage(chatId, \"Sorry, you're not authorized to use this bot.\");\r\n      }\r\n    }\r\n  }\r\n\r\n  isUserWhitelisted(userId: number): boolean {\r\n    return this.whitelistedUsers.includes(userId);\r\n  }\r\n\r\n  async handleWebhook(request: Request): Promise<Response> {\r\n    if (request.method !== 'POST') {\r\n      return new Response('Method Not Allowed', { status: 405 });\r\n    }\r\n\r\n    try {\r\n      const update: TelegramTypes.Update = await request.json();\r\n      await this.handleUpdate(update);\r\n      return new Response('OK', { status: 200 });\r\n    } catch (error) {\r\n      console.error('Error processing webhook:', error);\r\n      return new Response('Internal Server Error', { status: 500 });\r\n    }\r\n  }\r\n\r\n  async setWebhook(url: string): Promise<void> {\r\n    const setWebhookUrl = `${this.apiUrl}/setWebhook`;\r\n    const response = await fetch(setWebhookUrl, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({ url }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`Failed to set webhook: ${response.statusText}`);\r\n    }\r\n\r\n    const result: { ok: boolean; description?: string } = await response.json();\r\n    if (!result.ok) {\r\n      throw new Error(`Telegram API error: ${result.description}`);\r\n    }\r\n  }\r\n}\r\n\r\nexport default TelegramBot;", "import { Env } from './env';\r\nimport TelegramBot from './api/telegram';\r\n\r\nexport default {\r\n  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {\r\n    const bot = new TelegramBot(env);\r\n    const url = new URL(request.url);\r\n\r\n    console.log(`Received request for path: ${url.pathname}`);\r\n\r\n    try {\r\n      // Handle Telegram webhook\r\n      if (url.pathname === '/webhook') {\r\n        console.log('Processing webhook request');\r\n        return await bot.handleWebhook(request);\r\n      }\r\n\r\n      // Handle root path\r\n      if (url.pathname === '/' || url.pathname === '') {\r\n        console.log('Serving root path');\r\n        return new Response('Hello! This is your Telegram bot worker.', { \r\n          status: 200,\r\n          headers: { 'Content-Type': 'text/plain' }\r\n        });\r\n      }\r\n\r\n      // Handle all other requests\r\n      console.log('Path not found');\r\n      return new Response('Not Found', { \r\n        status: 404,\r\n        headers: { 'Content-Type': 'text/plain' }\r\n      });\r\n    } catch (error) {\r\n      console.error('Error processing request:', error);\r\n      return new Response('Internal Server Error', { \r\n        status: 500,\r\n        headers: { 'Content-Type': 'text/plain' }\r\n      });\r\n    }\r\n  },\r\n};"],
  "mappings": "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",
  "names": []
}
