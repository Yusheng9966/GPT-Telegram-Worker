{
  "version": 3,
  "sources": ["../src/env.ts", "../src/api/openai_api.ts", "../src/utils/helpers.ts", "../src/utils/i18n.ts", "../src/config/commands.ts", "../src/api/telegram.ts", "../src/index.ts"],
  "sourceRoot": "dist",
  "sourcesContent": ["export interface Env {\r\n  OPENAI_API_KEY: string;\r\n  OPENAI_BASE_URL: string;\r\n  OPENAI_MODELS: string; // Comma-separated list of available OpenAI models\r\n  TELEGRAM_BOT_TOKEN: string;\r\n  WHITELISTED_USERS: string; // Comma-separated list of allowed Telegram user IDs\r\n  SYSTEM_INIT_MESSAGE: string;\r\n  SYSTEM_INIT_MESSAGE_ROLE: string;\r\n  DEFAULT_MODEL?: string; // Optional default model\r\n}\r\n\r\nconst getEnvOrDefault = (env: Env, key: keyof Env, defaultValue: string): string => {\r\n  return (env[key] as string) || defaultValue;\r\n};\r\n\r\nexport const getConfig = (env: Env) => ({\r\n  openaiApiKey: env.OPENAI_API_KEY,\r\n  openaiBaseUrl: getEnvOrDefault(env, 'OPENAI_BASE_URL', 'https://api.openai.com/v1'),\r\n  openaiModels: env.OPENAI_MODELS.split(',').map(model => model.trim()),\r\n  telegramBotToken: env.TELEGRAM_BOT_TOKEN,\r\n  whitelistedUsers: env.WHITELISTED_USERS.split(',').map(id => id.trim()),\r\n  systemInitMessage: getEnvOrDefault(env, 'SYSTEM_INIT_MESSAGE', 'You are a helpful assistant.'),\r\n  systemInitMessageRole: getEnvOrDefault(env, 'SYSTEM_INIT_MESSAGE_ROLE', 'system'),\r\n  defaultModel: env.DEFAULT_MODEL\r\n});", "import { Env, getConfig } from '../env';\r\n\r\ninterface Message {\r\n  role: 'system' | 'user' | 'assistant';\r\n  content: string;\r\n}\r\n\r\ninterface ChatCompletionResponse {\r\n  id: string;\r\n  object: string;\r\n  created: number;\r\n  model: string;\r\n  choices: {\r\n    index: number;\r\n    message: Message;\r\n    finish_reason: string;\r\n  }[];\r\n  usage: {\r\n    prompt_tokens: number;\r\n    completion_tokens: number;\r\n    total_tokens: number;\r\n  };\r\n}\r\n\r\nexport class OpenAIAPI {\r\n  private apiKey: string;\r\n  private baseUrl: string;\r\n  private models: string[];\r\n  private defaultModel: string;\r\n\r\n  constructor(env: Env) {\r\n    const config = getConfig(env);\r\n    this.apiKey = config.openaiApiKey;\r\n    this.baseUrl = config.openaiBaseUrl;\r\n    this.models = config.openaiModels;\r\n    this.defaultModel = config.defaultModel || this.models[0];\r\n  }\r\n\r\n  async generateResponse(messages: Message[], model?: string): Promise<string> {\r\n    const url = `${this.baseUrl}/chat/completions`;\r\n    const response = await fetch(url, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'Authorization': `Bearer ${this.apiKey}`,\r\n      },\r\n      body: JSON.stringify({\r\n        model: model || this.defaultModel,\r\n        messages: messages,\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`OpenAI API error: ${response.statusText}`);\r\n    }\r\n\r\n    const data: ChatCompletionResponse = await response.json();\r\n    return data.choices[0].message.content.trim();\r\n  }\r\n\r\n  isValidModel(model: string): boolean {\r\n    return this.models.includes(model);\r\n  }\r\n\r\n  getDefaultModel(): string {\r\n    return this.defaultModel;\r\n  }\r\n\r\n  getAvailableModels(): string[] {\r\n    return this.models;\r\n  }\r\n}\r\n\r\nexport default OpenAIAPI;", "import { Env } from '../env';\r\n\r\nexport function formatCodeBlock(code: string, language: string): string {\r\n  return `\\`\\`\\`${language}\\n${code}\\n\\`\\`\\``;\r\n}\r\n\r\nexport function escapeMarkdown(text: string): string {\r\n  const specialChars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!'];\r\n  return specialChars.reduce((acc, char) => acc.replace(new RegExp(`\\\\${char}`, 'g'), `\\\\${char}`), text);\r\n}\r\n\r\nexport async function sendChatAction(chatId: number, action: string, env: Env): Promise<void> {\r\n  const token = env.TELEGRAM_BOT_TOKEN;\r\n  const url = `https://api.telegram.org/bot${token}/sendChatAction`;\r\n  await fetch(url, {\r\n    method: 'POST',\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n    },\r\n    body: JSON.stringify({\r\n      chat_id: chatId,\r\n      action: action,\r\n    }),\r\n  });\r\n}", "export type SupportedLanguages = 'en' | 'zh' | 'es';\r\n\r\ninterface Translations {\r\n  welcome: string;\r\n  unauthorized: string;\r\n  error: string;\r\n}\r\n\r\nconst translations: Record<SupportedLanguages, Translations> = {\r\n  en: {\r\n    welcome: \"Welcome to the GPT Telegram Bot! I'm here to assist you with any questions or tasks. Feel free to ask me anything!\",\r\n    unauthorized: \"Sorry, you're not authorized to use this bot.\",\r\n    error: \"Sorry, I couldn't generate a response. Please try again later.\",\r\n  },\r\n  zh: {\r\n    welcome: \"\u6B22\u8FCE\u4F7F\u7528GPT Telegram\u673A\u5668\u4EBA\uFF01\u6211\u968F\u65F6\u4E3A\u60A8\u89E3\u7B54\u95EE\u9898\u6216\u534F\u52A9\u5B8C\u6210\u4EFB\u52A1\u3002\u8BF7\u968F\u610F\u95EE\u6211\u4EFB\u4F55\u95EE\u9898\uFF01\",\r\n    unauthorized: \"\u62B1\u6B49\uFF0C\u60A8\u6CA1\u6709\u6743\u9650\u4F7F\u7528\u6B64\u673A\u5668\u4EBA\u3002\",\r\n    error: \"\u62B1\u6B49\uFF0C\u6211\u65E0\u6CD5\u751F\u6210\u56DE\u590D\u3002\u8BF7\u7A0D\u540E\u518D\u8BD5\u3002\",\r\n  },\r\n  es: {\r\n    welcome: \"\u00A1Bienvenido al Bot de Telegram GPT! Estoy aqu\u00ED para ayudarte con cualquier pregunta o tarea. \u00A1Si\u00E9ntete libre de preguntarme cualquier cosa!\",\r\n    unauthorized: \"Lo siento, no est\u00E1s autorizado para usar este bot.\",\r\n    error: \"Lo siento, no pude generar una respuesta. Por favor, int\u00E9ntalo de nuevo m\u00E1s tarde.\",\r\n  },\r\n};\r\n\r\nexport function translate(key: keyof Translations, language: SupportedLanguages = 'en'): string {\r\n  return translations[language]?.[key] || translations['en'][key];\r\n}", "import { TelegramBot } from '../api/telegram';\r\nimport { translate, SupportedLanguages } from '../utils/i18n';\r\n\r\nexport interface Command {\r\n  name: string;\r\n  description: string;\r\n  action: (chatId: number, bot: TelegramBot) => Promise<void>;\r\n}\r\n\r\nexport const commands: Command[] = [\r\n  {\r\n    name: 'start',\r\n    description: 'Start the bot',\r\n    action: async (chatId: number, bot: TelegramBot) => {\r\n      const language = 'en'; // You might want to get the user's language here\r\n      await bot.sendMessage(chatId, translate('welcome', language));\r\n    },\r\n  },\r\n  // Add more commands here as needed\r\n];", "import { Env, getConfig } from '../env';\r\nimport { TelegramTypes } from '../../types/telegram';\r\nimport OpenAIAPI from './openai_api';\r\nimport { formatCodeBlock, escapeMarkdown, sendChatAction } from '../utils/helpers';\r\nimport { translate, SupportedLanguages } from '../utils/i18n';\r\nimport { commands, Command } from '../config/commands';\r\n\r\nexport class TelegramBot {\r\n  private token: string;\r\n  private apiUrl: string;\r\n  private whitelistedUsers: number[];\r\n  private openai: OpenAIAPI;\r\n  private systemMessage: string;\r\n  private env: Env;\r\n  private commands: Command[];\r\n\r\n  constructor(env: Env) {\r\n    const config = getConfig(env);\r\n    this.token = config.telegramBotToken;\r\n    this.apiUrl = `https://api.telegram.org/bot${this.token}`;\r\n    this.whitelistedUsers = config.whitelistedUsers.map(Number);\r\n    this.openai = new OpenAIAPI(env);\r\n    this.systemMessage = config.systemInitMessage;\r\n    this.env = env;\r\n    this.commands = commands;\r\n  }\r\n\r\n  public async executeCommand(commandName: string, chatId: number): Promise<void> {\r\n    const command = this.commands.find(cmd => cmd.name === commandName);\r\n    if (command) {\r\n      await command.action(chatId, this);\r\n    } else {\r\n      console.log(`Unknown command: ${commandName}`);\r\n    }\r\n  }\r\n\r\n  async sendMessage(chatId: number, text: string, parseMode: 'Markdown' | 'HTML' = 'Markdown'): Promise<TelegramTypes.SendMessageResult> {\r\n    const url = `${this.apiUrl}/sendMessage`;\r\n    const response = await fetch(url, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        chat_id: chatId,\r\n        text: text,\r\n        parse_mode: parseMode,\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`HTTP error! status: ${response.status}`);\r\n    }\r\n\r\n    return await response.json();\r\n  }\r\n\r\n  async handleUpdate(update: TelegramTypes.Update): Promise<void> {\r\n    if (update.message && update.message.text) {\r\n      const chatId = update.message.chat.id;\r\n      const userId = update.message.from?.id;\r\n      const text = update.message.text;\r\n      const language = (update.message.from?.language_code as SupportedLanguages) || 'en';\r\n\r\n      if (userId && this.isUserWhitelisted(userId)) {\r\n        if (text.startsWith('/')) {\r\n          const commandName = text.split(' ')[0].substring(1);\r\n          await this.executeCommand(commandName, chatId);\r\n        } else {\r\n          try {\r\n            await sendChatAction(chatId, 'typing', this.env);\r\n            const response = await this.openai.generateResponse([\r\n              { role: 'system', content: this.systemMessage },\r\n              { role: 'user', content: text }\r\n            ]);\r\n            const formattedResponse = this.formatResponse(response);\r\n            await this.sendMessage(chatId, formattedResponse);\r\n          } catch (error) {\r\n            console.error('Error generating response:', error);\r\n            await this.sendMessage(chatId, translate('error', language));\r\n          }\r\n        }\r\n      } else {\r\n        await this.sendMessage(chatId, translate('unauthorized', language));\r\n      }\r\n    }\r\n  }\r\n\r\n  private async getChatMember(chatId: number): Promise<TelegramTypes.ChatMember> {\r\n    const url = `${this.apiUrl}/getChatMember`;\r\n    const response = await fetch(url, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        chat_id: chatId,\r\n        user_id: chatId,\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`HTTP error! status: ${response.status}`);\r\n    }\r\n\r\n    const result: TelegramTypes.GetChatMemberResult = await response.json();\r\n    if (!result.ok) {\r\n      throw new Error('Failed to get chat member');\r\n    }\r\n    return result.result;\r\n  }\r\n\r\n  formatResponse(response: string): string {\r\n    const codeBlockRegex = /```(\\w+)?\\n([\\s\\S]+?)```/g;\r\n    return response.replace(codeBlockRegex, (match, language, code) => {\r\n      return formatCodeBlock(code.trim(), language || '');\r\n    });\r\n  }\r\n\r\n  isUserWhitelisted(userId: number): boolean {\r\n    return this.whitelistedUsers.includes(userId);\r\n  }\r\n\r\n  async handleWebhook(request: Request): Promise<Response> {\r\n    if (request.method !== 'POST') {\r\n      return new Response('Method Not Allowed', { status: 405 });\r\n    }\r\n\r\n    try {\r\n      const update: TelegramTypes.Update = await request.json();\r\n      await this.handleUpdate(update);\r\n      return new Response('OK', { status: 200 });\r\n    } catch (error) {\r\n      console.error('Error processing webhook:', error);\r\n      return new Response('Internal Server Error', { status: 500 });\r\n    }\r\n  }\r\n\r\n  async setWebhook(url: string): Promise<void> {\r\n    const setWebhookUrl = `${this.apiUrl}/setWebhook`;\r\n    const response = await fetch(setWebhookUrl, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({ url }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`Failed to set webhook: ${response.statusText}`);\r\n    }\r\n\r\n    const result: { ok: boolean; description?: string } = await response.json();\r\n    if (!result.ok) {\r\n      throw new Error(`Telegram API error: ${result.description}`);\r\n    }\r\n  }\r\n}\r\n\r\nexport default TelegramBot;", "import { Env } from './env';\r\nimport TelegramBot from './api/telegram';\r\n\r\nexport default {\r\n  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {\r\n    const bot = new TelegramBot(env);\r\n    const url = new URL(request.url);\r\n\r\n    console.log(`Received request for path: ${url.pathname}`);\r\n\r\n    try {\r\n      // Handle Telegram webhook\r\n      if (url.pathname === '/webhook') {\r\n        console.log('Processing webhook request');\r\n        return await bot.handleWebhook(request);\r\n      }\r\n\r\n      // Handle root path\r\n      if (url.pathname === '/' || url.pathname === '') {\r\n        console.log('Serving root path');\r\n        return new Response('Hello! This is your Telegram bot worker.', { \r\n          status: 200,\r\n          headers: { 'Content-Type': 'text/plain' }\r\n        });\r\n      }\r\n\r\n      // Handle all other requests\r\n      console.log('Path not found');\r\n      return new Response('Not Found', { \r\n        status: 404,\r\n        headers: { 'Content-Type': 'text/plain' }\r\n      });\r\n    } catch (error) {\r\n      console.error('Error processing request:', error);\r\n      const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';\r\n      return new Response(`Internal Server Error: ${errorMessage}`, { \r\n        status: 500,\r\n        headers: { 'Content-Type': 'text/plain' }\r\n      });\r\n    }\r\n  },\r\n};"],
  "mappings": "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",
  "names": []
}
